# 연결 리스트 (Linked list)

#### 1. 정의
- 데이터를 가진 노드(Node)와 다음 노드를 가리키는 포인터(Pointer)로 구성되며, 데이터를 순서대로 저장하는 자료구조입니다.

#### 2. 구조
- 노드(node)의 구성
  - 데이터(data) : 저장하고자 하는 값
  - 포인터(pointer): 다음 노드의 주소
- 노드의 명칭
  - 헤드(head): 첫번째 노드
  - 테일(tail): 마지막 노드

#### 3. 특징
- 배열처럼 순서대로 데이터를 저장할 수 있습니다.
- 다만, 배열과 달리 메모리가 연속적이지 않아도 됩니다.
  - 배열은 연속적인 메모리 공간을 사용해야합니다.
  - 연결리스트는 포인터에 다음 노드의 주소를 가지고 있기 때문에, 불연속적이어도 됩니다.
- 데이터의 삽입과 삭제하는 것 자체는 포인터만 수정하면 되기 때문에 효율적입니다. (시간복잡도: O(1))

#### 4. 자료구조 사용 판단 기준
- 데이터의 삽입과 삭제가 빈번한 경우에 사용을 고려할 수 있습니다.(특히 중간 삽입과 삭제가 중요한 상황)

#### 5. 종류
- 단일 연결 리스트
  - 다음 노드의 정보를 가지고 있는 리스트
  - 구조가 간단하고, 데이터의 삽입과 삭제가 효율적입니다.
  - 역방향으로 탐색이 불가능하여, 처음부터 끝까지 순회하며 탐색해야합니다.
- 양방향 연결 리스트
  - 양쪽 노드의 정보를 가지고 있는 리스트
  - 노드의 삽입과 삭제가 더 유연합니다. 다양한 방향으로 탐색이 가능합니다.
  - 추가적인 포인터(prev)를 저장해야하여 메모리를 더 사용합니다.
- 원형 연결 리스트
  - 마지막 노드가 첫번째 노드의 주소를 가지고 있는 리스트입니다.
  - 양쪽 노드가 연결되어있어 순환 처리가 필요할 때 효율적입니다.
  - 잘못된 구현으로 무한 루프에 빠질 수 있으므로 구현에 주의해야합니다.

#### 6. 데이터의 삽입
- 삽입할 공간의 탐색에 O(n), 삽입에 O(1)로 O(n)의 시간 복잡도를 갖습니다.
- 삽입 위치만 찾는다면 포인터만 교체해주면 되기 때문에 삽입 자체는 O(1)입니다.

#### 7. 데이터의 조회
- 연결 리스트의 헤드부터 순차적으로 이동하며 찾고자하는 데이터와 일치하는 데이터를 가진 노드가 있는지 확인해야합니다. O(n)의 시간 복잡도를 가집니다. 최선의 경우 데이터가 헤드에 있으면 O(1)입니다.

#### 8. 데이터의 삭제
- 헤드부터 탐색하여 삭제해야하는 데이터를 찾습니다.(O(n)) 데이터를 찾으면 이전 노드의 포인터에 다음 노드의 주소를 할당합니다.(O(1))

#### 9. 배열과 비교
**정적 배열**
- 정의: 프로그램 실행 전에 배열의 크기를 미리 선언하여 고정된 메모리를 사용하는 자료구조
- 특징: 컴파일 타임에 메모리가 할당
- 예시: C언어
- 장점: 데이터 접근 속도가 빠르고, 메모리 사용에 효율적(메모리 구조가 단순하고, 오버헤드가 없기 때문)
- 단점:
  - 크기를 미리 정하는 방식으로 인하여 공간 크기 부족과 과잉 할당될 가능성 존재
  - 삽입과 삭제를 위해 데이터를 이동해야하기 때문에 O(n)의 시간복잡도를 가집니다.
- 적용 판단 기준: 데이터의 크기가 고정적일 때 고려할 수 있습니다.

**동적 배열**
- 정의: 미리 배열의 크기를 고정하지 않고, 필요에 따라 유연하게 조정하는 자료구조
- 특징
  - 런타임에 메모리를 동적으로 할당
  - 크기가 초과되면 추가적인 메모리 공간을 할당하고 기존 데이터를 복사해서 확장
  - 이 과정에서 성능에 영향을 미칠 수도 있습니다.
- 예시: 파이썬 list
- 장점: 정적 배열과 동일하게 데이터 접근 속도가 빠릅니다.
- 단점: 
  - 삽입 시 배열의 크기가 부족하면, 확장을 위해 새로운 메모리 블록을 만들어서 기존 데이터를 복사하는 작업이 필요하기 때문에 성능저하가 있을 수 있습니다. 
  - 정적 배열과 동일하게 삽입과 삭제를 위해 데이터를 이동해야하기 때문에 O(n)의 시간복잡도를 가집니다. 
- 적용 판단 기준:
  - 데이터의 삽입과 삭제가 양 끝에서 이루어지고, 크기가 자주 변하지않을 때 적합합니다.
  - 크기가 변동되는 데이터를 유연하게 관리해야하는 상황
  - (사용자 입력에 따라 데이터를 동적으로 관리하는 경우)

**정적 배열과 동적 배열의 차이점**
1. 메모리 할당 방식
  - 정적 배열: 배열의 크기는 프로그램 실행전에 고정, 컴파일 타임에서 고정된 메모리 공간을 할당
  - 동적 배열: 배열의 크기는 필요에 따라 변경 가능, 런타임에 메모리를 동적으로 할당
2. 크기 조정 가능 여부
  - 정적 배열: 실행 중에 크기 변경 불가능
  - 동적 배열: 데이터 추가 및 삭제로 크기 조절 가능
3. 데이터 접근 속도
  - 둘 다 동일하게 인덱스로 접근하며, O(1)의 시간 복잡도로 데이터에 접근 가능
4. 삽입과 삭제
  - 삽입 시 배열에 공간이 없을 경우
    - 정적 배열: 오류를 반환합니다.
    - 동적 배열: 현재 배열보다 더 큰 배열을 만들고, 기존 배열을 새로운 배열에 하나씩 복사한 후에 삽입할 공간을 찾고 공간 확보를 위해 배열에서 데이터를 밀어 이동시킵니다.
  - 삭제 시 동적 배열은 삭제 이후에 공간을 줄일 필요가 있다면 조정할 수 있습니다. (근데 크기 줄이기도 비용입니다.)
5. 메모리 효율성
  - 정적 배열: 크기가 고정되어있어 메모리 낭비가 없습니다.
  - 동적 배열: 크기 확장 시 남는 메모리가 있거나, 데이터 복사로 인해 추가적인 메모리의 오버헤드가 있을 수 있습니다.

**정적 배열과 동적 배열의 공통점**
1. 삽입
  - 배열의 양 끝이 아닌 공간에 데이터를 추가한다면, 해당 공간의 오른쪽 배열들이 이동해야 하기 때문에 O(n)의 시간복잡도로 비용이 큽니다. 배열 양 끝에서의 삽입과 삭제는 O(1)의 시간복잡도로 비용이 적습니다.
2. 조회
  - 인덱스가 배열의 길이보다 작은지 확인한 후, 인덱스로 데이터에 접근합니다.
  - O(1)으로 조회가 빠릅니다.
3. 삭제
  - 삭제할 데이터 이후의 데이터들을 한칸씩 앞으로 당겨야하므로 O(n)의 시간복잡도를 갖습니다.
  - 마지막 요소를 삭제하는 경우에는 데이터의 이동이 필요없으므로 O(1)의 시간복잡도를 갖습니다.
